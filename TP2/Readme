Mercier Tony
Jones Marie 

ACT - TP2 : Programmation dynamique 

Partie 1 : Implémentation 

-- Meilleur gris  : on suppose qu'on dispose d'une palette qui est un tableau allant de 0 à 255 et qui pour chaque case contient le nombre 
de pixels ayant pour niveau de gris l'indice de cette case

    entrée : premier ,dernier des entiers >= 0 , <= 255, premier < dernier ;
    sortie : moyenne pondérée de la tranche entre le premier et le dernier gris 

    debut 

        soient nb_total et somme_coeff des entiers; 

        pour i allant de premier à dernier 

            nb_total <- palette[i] + nb_total;
            somme_coeff <- somme_coeff + palette[i]*i;
        fin pour; 

        retourner Partie_Entiere(somme_coeff/nb_total);

    fin 

-- Distance Minimale : comme pour meilleur gris nous disposons de la même palette 

    entrée : premier , dernier des entiers >=0 , <= 255 , premier < dernier;
    sortie : la distance minimale qu'entraine la fusion d'un intervalle de la palette 

    debut

        soient meilleur et dist des entiers;

        meilleur = meilleur_gris(premier,dernier);

        pour i allant de premier à dernier 

            dist <- dist + (i - meilleur)^2 * palette[i]; 
        fin pour;

        retourner arrondi(dist);
    fin 

-- Décomposition de l'image 

    distance (palette(i ... n),k) = distance_min (i,j) + distance(palette(j ... n), k -1)

    Algorithme : on suppose qu'on dispose d'une palette comme pour meilleur_gris

    entrée : n , k des entiers >0;
    sortie : un tableau contenant l'indice de début des intervalles, excepté pour le premier où on sait qu'il vaut 0 

    début 

        soient tab un tableau à 256 cases de tableaux à 256 cases 
        soit rem un tableau à k cases
        soient d,cpt,fin,i,j,m,p des entiers;

        //initialisation du tableau 

        pour i allant de 0 à 255 faire 
            pour j allant de 0 à 255 faire 

                //la diagonale vaut 0 sinon on initialise avec le plus grand nombre possible 
                si i = j alors
                    tab[i][j] = 0
                sinon 
                    tab[i][j] = MaxInt
                fin si

            fin pour 
        fin pour

        //on appelle la fonction récursive sur toute la palette avec k découpes
        rec(0,255,k)

        //Remontée 
        d = tab[0][255]
        cpt = k -1
        fin = 255
        tant que (d != 0 ) faire
          
          pour m allant de cpt à 0 faire
            
            pour p allant de fin à 0 faire 

                si (tab[p][fin] != MaxInt) alors

                    fin = p -1; 
                    d = d - tab[p][fin]
                    rem[cpt] = p
                    sortir de la boucle sur p 

                fin si
            fin pour
          fin pour

          si d < 0 alors 
            d = tab[0][255]
          fin si 

        fin tant que

        retourner rem;

    fin

    -- Fonction récursive : 

        entrée : debut, fin des entiers >= 0 , <= 255
                k un entier >= 0

        sortie : distance minimale de la réduction de la palette

        debut 

            si k = 1 alors

                si tab[debut][fin] = MaxInt alors
                    tab[debut][fin] = distance_min(debut,fin)
                fin si 
                retourne tab[debut][fin]

            sinon 

                pour j allant de debut + 1 à fin - 1  faire 
                    si palette[j] != 0 faire 

                        si tab[debut][j] = MaxInt faire 
                            tab[debut][j] = distance_min(debut,j)
                         fin si 

                         tab[debut][fin] = min(tab[debut][fin], tab[debut][j] + rec(j+1,fin,k -1))
                     fin si 
                fin pour 
            fin si
        fin

-- Calcul d'une nouvelle palette pour une image 

    entrée : img une image  au format d'un tableau deux dimensions 
            k le nombre de couleurs qu'on veut pour l'image 

    sortie : un tableau à deux dimensions représentant la nouvelle image 

    soit palette un tableau d'entier de taille 256
    soit tab un tableau de taille k -1
    soit new_gris un tableau de taille k 
    soit nouvelle_image un tableau de tableaux aux mêmes dimensions que img
    soient i, j ,l,tmp,debut des entiers

    pour i allant de 0 à img.largeur faire 
        pour j allant de 0 à img[i].longueur faire

            palette[conversion_en_entier(img[i][j])]++;

        fin pour
    fin pour

    tab = reduction(palette,k)

    debut = 0
    pour i allant de 0 à k -1 faire 
        new_gris[i] = meilleur_gris(debut,tab[i] -1)
        debut = tab[i]
    fin pour 
    new_gris[k] = meilleur_gris(debut,255)

    pour i allant de 0 à img.largeur faire
        pour j allant de 0 à img[i].longueur faire
            tmp = img[i][j]
            si tmp > tab[k -2] alors 
                nouvelle_image[i][j] = new_gris[k -1]
            sinon 
                pour l allant de 0 à k -1 alors 
                    si tmp < tab[l] alors 
                        nouvelle_image[i][j] = new_gris[l]
                        sortir de la boucle 
                    fin si
                fin pour 
            fin si 
        fin pour 
    fin pour 

    retourner nouvelle_image
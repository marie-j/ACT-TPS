Mercier Tony
Jones Marie 

ACT - TP2 : Programmation dynamique 

Partie 1 : Implémentation 

-- Meilleur gris  : on suppose qu'on dispose d'une palette qui est un tableau allant de 0 à 255 et qui pour chaque case contient le nombre 
de pixels ayant pour niveau de gris l'indice de cette case

    entrée : premier ,dernier des entiers >= 0 , <= 255, premier < dernier ;
    sortie : moyenne pondérée de la tranche entre le premier et le dernier gris 

    debut 

        soient nb_total et somme_coeff des entiers; 

        pour i allant de premier à dernier 

            nb_total <- palette[i] + nb_total;
            somme_coeff <- somme_coeff + palette[i]*i;
        fin pour; 

        retourner Partie_Entiere(somme_coeff/nb_total);

    fin 

-- Distance Minimale : comme pour meilleur gris nous disposons de la même palette 

    entrée : premier , dernier des entiers >=0 , <= 255 , premier < dernier;
    sortie : la distance minimale qu'entraine la fusion d'un intervalle de la palette 

    debut

        soient meilleur et dist des entiers;

        meilleur = meilleur_gris(premier,dernier);

        pour i allant de premier à dernier 

            dist <- dist + (i - meilleur)^2 * palette[i]; 
        fin pour;

        retourner dist;
    fin 

-- Décomposition de l'image 

    distance (palette(i ... n),k) = distance_min (i,j) + distance(palette(j ... n), k -1)

    Algorithme : on suppose qu'on dispose d'une palette comme pour meilleur_gris

    entrée : n , k des entiers >0;
    sortie : distance minimale de la réduction de la palette 

    début 

        soient tab un tableau à 256 cases de tableaux à 256 cases 

        //initialisation du tableau 

        pour i allant de 0 à 255 faire 
            pour j allant de 0 à 255 faire 

                //la diagonale vaut 0 sinon on initialise avec le plus grand nombre possible 
                si i = j alors
                    tab[i][j] = 0
                sinon 
                    tab[i][j] = MaxInt
                fin si

            fin pour 
        fin pour

        //on appelle la fonction récursive sur toute la palette avec k découpes
        rec(0,255,k)
    fin

    -- Fonction récursive : 

        entrée : debut, fin des entiers >= 0 , <= 255
                k un entier >= 0

        sortie : distance minimale de la réduction de la palette

        debut 

            si k = 0 alors

                si tab[debut][fin] = MaxInt alors
                    tab[debut][fin] = distance_min(debut,fin)
                fin si 
                retourne tab[debut][fin]

            sinon 
                
                pour i allant de debut à fin faire 

                    si palette[i] != 0 faire 
                        pour j allant de i +1 à fin faire 
                            si palette[j] != 0 faire 

                                si tab[i][j] = MaxInt faire 
                                    tab[i][j] = distance_min(i,j)
                                fin si 

                                tab[debut][fin] = min(tab[debut][fin], tab[i][j] + rec(j+1,fin,k -1))

                            fin si 
                        fin pour 
                    fin si
                fin pour 
            fin si
        fin
    
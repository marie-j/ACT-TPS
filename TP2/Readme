Mercier Tony
Jones Marie 

ACT - TP2 : Programmation dynamique 

Partie 1 : Implémentation 

-- Meilleur gris  : on suppose qu'on dispose d'une palette qui est un tableau allant de 0 à 255 et qui pour chaque case contient le nombre 
de pixels ayant pour niveau de gris l'indice de cette case

    entrée : premier ,dernier des entiers >= 0 , <= 255, premier < dernier ;
    sortie : moyenne pondérée de la tranche entre le premier et le dernier gris 

    debut 

        soient nb_total et somme_coeff des entiers; 

        pour i allant de premier à dernier 

            nb_total <- palette[i] + nb_total;
            somme_coeff <- somme_coeff + palette[i]*i;
        fin pour; 

        retourner Partie_Entiere(somme_coeff/nb_total);

    fin 

-- Distance Minimale : comme pour meilleur gris nous disposons de la même palette 

    entrée : premier , dernier des entiers >=0 , <= 255 , premier < dernier;
    sortie : la distance minimale qu'entraine la fusion d'un intervalle de la palette 

    debut

        soient meilleur et dist des entiers;

        meilleur = meilleur_gris(premier,dernier);

        pour i allant de premier à dernier 

            dist <- dist + (i - meilleur)^2 * palette[i]; 
        fin pour;

        retourner dist;
    fin 

-- Décomposition de l'image 

    distance (palette(i ... n),k) = distance_min (i,j) + distance(palette(j ... n), k -1)

    Algorithme : on suppose qu'on dispose d'une palette comme pour meilleur_gris

    entrée : n , k des entiers >0;
    sortie : distance minimale de la réduction de la palette 

    début 

        soient tab un tableau à 256 cases de tableaux à 256 cases 
        soit rem un tableau à kl-1 cases
        soientt d,cpt un entier;

        //initialisation du tableau 

        pour i allant de 0 à 255 faire 
            pour j allant de 0 à 255 faire 

                //la diagonale vaut 0 sinon on initialise avec le plus grand nombre possible 
                si i = j alors
                    tab[i][j] = 0
                sinon 
                    tab[i][j] = MaxInt
                fin si

            fin pour 
        fin pour

        //on appelle la fonction récursive sur toute la palette avec k découpes
        rec(0,255,k)

        //Remontée 
        d = tab[0][255]
        cpt = k - 1
        tant que (d != 0 && k != 0) faire
          
            
                
        fin tant que 

    fin

    -- Fonction récursive : 

        entrée : debut, fin des entiers >= 0 , <= 255
                k un entier >= 0

        sortie : distance minimale de la réduction de la palette

        debut 

            si k = 1 alors

                si tab[debut][fin] = MaxInt alors
                    tab[debut][fin] = distance_min(debut,fin)
                fin si 
                retourne tab[debut][fin]

            sinon 

                pour j allant de debut + 1 à fin - 1  faire 
                    si palette[j] != 0 faire 

                        si tab[debut][j] = MaxInt faire 
                            tab[debut][j] = distance_min(debut,j)
                         fin si 

                         tab[debut][fin] = min(tab[debut][fin], tab[debut][j] + rec(j+1,fin,k -1))
                     fin si 
                fin pour 
            fin si
        fin
    